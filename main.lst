CCS PCM C Compiler, Version 5.074, 32906               16-Dec-17 18:09

               Filename:   C:\Users\peera\Documents\Work\LIL\hopher\modbus\main.lst

               ROM used:   1942 words (24%)
                           Largest free fragment is 2048
               RAM used:   96 (9%) at main() level
                           123 (12%) worst case
               Stack used: 7 locations (4 in main + 3 for interrupts)
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   5AB
0002:  NOP
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVLB  10
0010:  MOVF   1A,W
0011:  MOVLB  00
0012:  MOVWF  24
0013:  MOVLB  10
0014:  MOVF   1B,W
0015:  MOVLB  00
0016:  MOVWF  25
0017:  MOVLB  10
0018:  MOVF   1C,W
0019:  MOVLB  00
001A:  MOVWF  26
001B:  MOVLB  10
001C:  MOVF   1D,W
001D:  MOVLB  00
001E:  MOVWF  27
001F:  MOVLW  07
0020:  MOVWF  05
0021:  MOVLW  1A
0022:  MOVWF  04
0023:  BTFSS  00.0
0024:  GOTO   02B
0025:  MOVLW  07
0026:  MOVWF  05
0027:  MOVLW  10
0028:  MOVWF  04
0029:  BTFSC  00.0
002A:  GOTO   050
002B:  MOVLW  07
002C:  MOVWF  05
002D:  MOVLW  19
002E:  MOVWF  04
002F:  BTFSS  00.7
0030:  GOTO   037
0031:  MOVLW  07
0032:  MOVWF  05
0033:  MOVLW  0F
0034:  MOVWF  04
0035:  BTFSC  00.7
0036:  GOTO   052
0037:  MOVF   20,W
0038:  MOVWF  77
0039:  MOVF   21,W
003A:  MOVWF  78
003B:  MOVF   22,W
003C:  MOVWF  79
003D:  MOVF   23,W
003E:  MOVWF  7A
003F:  MOVF   24,W
0040:  MOVLB  10
0041:  MOVWF  1A
0042:  MOVLB  00
0043:  MOVF   25,W
0044:  MOVLB  10
0045:  MOVWF  1B
0046:  MOVLB  00
0047:  MOVF   26,W
0048:  MOVLB  10
0049:  MOVWF  1C
004A:  MOVLB  00
004B:  MOVF   27,W
004C:  MOVLB  10
004D:  MOVWF  1D
004E:  RETFIE
004F:  MOVLB  00
0050:  MOVLP  00
0051:  GOTO   256
0052:  MOVLP  00
0053:  GOTO   2B3
.................... #include <16F15345.h> 
.................... //////////// Standard Header file for the PIC16F15345 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
*
0257:  MOVLB  0E
0258:  BCF    10.0
0259:  MOVLB  00
025A:  MOVLP  00
025B:  MOVLB  00
025C:  GOTO   037
.................... #device PIC16F15345 
*
0054:  BRW
0055:  RETLW  00
0056:  RETLW  C1
0057:  RETLW  81
0058:  RETLW  40
0059:  RETLW  01
005A:  RETLW  C0
005B:  RETLW  80
005C:  RETLW  41
005D:  RETLW  01
005E:  RETLW  C0
005F:  RETLW  80
0060:  RETLW  41
0061:  RETLW  00
0062:  RETLW  C1
0063:  RETLW  81
0064:  RETLW  40
0065:  RETLW  01
0066:  RETLW  C0
0067:  RETLW  80
0068:  RETLW  41
0069:  RETLW  00
006A:  RETLW  C1
006B:  RETLW  81
006C:  RETLW  40
006D:  RETLW  00
006E:  RETLW  C1
006F:  RETLW  81
0070:  RETLW  40
0071:  RETLW  01
0072:  RETLW  C0
0073:  RETLW  80
0074:  RETLW  41
0075:  RETLW  01
0076:  RETLW  C0
0077:  RETLW  80
0078:  RETLW  41
0079:  RETLW  00
007A:  RETLW  C1
007B:  RETLW  81
007C:  RETLW  40
007D:  RETLW  00
007E:  RETLW  C1
007F:  RETLW  81
0080:  RETLW  40
0081:  RETLW  01
0082:  RETLW  C0
0083:  RETLW  80
0084:  RETLW  41
0085:  RETLW  00
0086:  RETLW  C1
0087:  RETLW  81
0088:  RETLW  40
0089:  RETLW  01
008A:  RETLW  C0
008B:  RETLW  80
008C:  RETLW  41
008D:  RETLW  01
008E:  RETLW  C0
008F:  RETLW  80
0090:  RETLW  41
0091:  RETLW  00
0092:  RETLW  C1
0093:  RETLW  81
0094:  RETLW  40
0095:  RETLW  01
0096:  RETLW  C0
0097:  RETLW  80
0098:  RETLW  41
0099:  RETLW  00
009A:  RETLW  C1
009B:  RETLW  81
009C:  RETLW  40
009D:  RETLW  00
009E:  RETLW  C1
009F:  RETLW  81
00A0:  RETLW  40
00A1:  RETLW  01
00A2:  RETLW  C0
00A3:  RETLW  80
00A4:  RETLW  41
00A5:  RETLW  00
00A6:  RETLW  C1
00A7:  RETLW  81
00A8:  RETLW  40
00A9:  RETLW  01
00AA:  RETLW  C0
00AB:  RETLW  80
00AC:  RETLW  41
00AD:  RETLW  01
00AE:  RETLW  C0
00AF:  RETLW  80
00B0:  RETLW  41
00B1:  RETLW  00
00B2:  RETLW  C1
00B3:  RETLW  81
00B4:  RETLW  40
00B5:  RETLW  00
00B6:  RETLW  C1
00B7:  RETLW  81
00B8:  RETLW  40
00B9:  RETLW  01
00BA:  RETLW  C0
00BB:  RETLW  80
00BC:  RETLW  41
00BD:  RETLW  01
00BE:  RETLW  C0
00BF:  RETLW  80
00C0:  RETLW  41
00C1:  RETLW  00
00C2:  RETLW  C1
00C3:  RETLW  81
00C4:  RETLW  40
00C5:  RETLW  01
00C6:  RETLW  C0
00C7:  RETLW  80
00C8:  RETLW  41
00C9:  RETLW  00
00CA:  RETLW  C1
00CB:  RETLW  81
00CC:  RETLW  40
00CD:  RETLW  00
00CE:  RETLW  C1
00CF:  RETLW  81
00D0:  RETLW  40
00D1:  RETLW  01
00D2:  RETLW  C0
00D3:  RETLW  80
00D4:  RETLW  41
00D5:  RETLW  01
00D6:  RETLW  C0
00D7:  RETLW  80
00D8:  RETLW  41
00D9:  RETLW  00
00DA:  RETLW  C1
00DB:  RETLW  81
00DC:  RETLW  40
00DD:  RETLW  00
00DE:  RETLW  C1
00DF:  RETLW  81
00E0:  RETLW  40
00E1:  RETLW  01
00E2:  RETLW  C0
00E3:  RETLW  80
00E4:  RETLW  41
00E5:  RETLW  00
00E6:  RETLW  C1
00E7:  RETLW  81
00E8:  RETLW  40
00E9:  RETLW  01
00EA:  RETLW  C0
00EB:  RETLW  80
00EC:  RETLW  41
00ED:  RETLW  01
00EE:  RETLW  C0
00EF:  RETLW  80
00F0:  RETLW  41
00F1:  RETLW  00
00F2:  RETLW  C1
00F3:  RETLW  81
00F4:  RETLW  40
00F5:  RETLW  00
00F6:  RETLW  C1
00F7:  RETLW  81
00F8:  RETLW  40
00F9:  RETLW  01
00FA:  RETLW  C0
00FB:  RETLW  80
00FC:  RETLW  41
00FD:  RETLW  01
00FE:  RETLW  C0
00FF:  RETLW  80
0100:  RETLW  41
0101:  RETLW  00
0102:  RETLW  C1
0103:  RETLW  81
0104:  RETLW  40
0105:  RETLW  01
0106:  RETLW  C0
0107:  RETLW  80
0108:  RETLW  41
0109:  RETLW  00
010A:  RETLW  C1
010B:  RETLW  81
010C:  RETLW  40
010D:  RETLW  00
010E:  RETLW  C1
010F:  RETLW  81
0110:  RETLW  40
0111:  RETLW  01
0112:  RETLW  C0
0113:  RETLW  80
0114:  RETLW  41
0115:  RETLW  00
0116:  RETLW  C1
0117:  RETLW  81
0118:  RETLW  40
0119:  RETLW  01
011A:  RETLW  C0
011B:  RETLW  80
011C:  RETLW  41
011D:  RETLW  01
011E:  RETLW  C0
011F:  RETLW  80
0120:  RETLW  41
0121:  RETLW  00
0122:  RETLW  C1
0123:  RETLW  81
0124:  RETLW  40
0125:  RETLW  01
0126:  RETLW  C0
0127:  RETLW  80
0128:  RETLW  41
0129:  RETLW  00
012A:  RETLW  C1
012B:  RETLW  81
012C:  RETLW  40
012D:  RETLW  00
012E:  RETLW  C1
012F:  RETLW  81
0130:  RETLW  40
0131:  RETLW  01
0132:  RETLW  C0
0133:  RETLW  80
0134:  RETLW  41
0135:  RETLW  01
0136:  RETLW  C0
0137:  RETLW  80
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  C1
013B:  RETLW  81
013C:  RETLW  40
013D:  RETLW  00
013E:  RETLW  C1
013F:  RETLW  81
0140:  RETLW  40
0141:  RETLW  01
0142:  RETLW  C0
0143:  RETLW  80
0144:  RETLW  41
0145:  RETLW  00
0146:  RETLW  C1
0147:  RETLW  81
0148:  RETLW  40
0149:  RETLW  01
014A:  RETLW  C0
014B:  RETLW  80
014C:  RETLW  41
014D:  RETLW  01
014E:  RETLW  C0
014F:  RETLW  80
0150:  RETLW  41
0151:  RETLW  00
0152:  RETLW  C1
0153:  RETLW  81
0154:  RETLW  40
0155:  BRW
0156:  RETLW  00
0157:  RETLW  C0
0158:  RETLW  C1
0159:  RETLW  01
015A:  RETLW  C3
015B:  RETLW  03
015C:  RETLW  02
015D:  RETLW  C2
015E:  RETLW  C6
015F:  RETLW  06
0160:  RETLW  07
0161:  RETLW  C7
0162:  RETLW  05
0163:  RETLW  C5
0164:  RETLW  C4
0165:  RETLW  04
0166:  RETLW  CC
0167:  RETLW  0C
0168:  RETLW  0D
0169:  RETLW  CD
016A:  RETLW  0F
016B:  RETLW  CF
016C:  RETLW  CE
016D:  RETLW  0E
016E:  RETLW  0A
016F:  RETLW  CA
0170:  RETLW  CB
0171:  RETLW  0B
0172:  RETLW  C9
0173:  RETLW  09
0174:  RETLW  08
0175:  RETLW  C8
0176:  RETLW  D8
0177:  RETLW  18
0178:  RETLW  19
0179:  RETLW  D9
017A:  RETLW  1B
017B:  RETLW  DB
017C:  RETLW  DA
017D:  RETLW  1A
017E:  RETLW  1E
017F:  RETLW  DE
0180:  RETLW  DF
0181:  RETLW  1F
0182:  RETLW  DD
0183:  RETLW  1D
0184:  RETLW  1C
0185:  RETLW  DC
0186:  RETLW  14
0187:  RETLW  D4
0188:  RETLW  D5
0189:  RETLW  15
018A:  RETLW  D7
018B:  RETLW  17
018C:  RETLW  16
018D:  RETLW  D6
018E:  RETLW  D2
018F:  RETLW  12
0190:  RETLW  13
0191:  RETLW  D3
0192:  RETLW  11
0193:  RETLW  D1
0194:  RETLW  D0
0195:  RETLW  10
0196:  RETLW  F0
0197:  RETLW  30
0198:  RETLW  31
0199:  RETLW  F1
019A:  RETLW  33
019B:  RETLW  F3
019C:  RETLW  F2
019D:  RETLW  32
019E:  RETLW  36
019F:  RETLW  F6
01A0:  RETLW  F7
01A1:  RETLW  37
01A2:  RETLW  F5
01A3:  RETLW  35
01A4:  RETLW  34
01A5:  RETLW  F4
01A6:  RETLW  3C
01A7:  RETLW  FC
01A8:  RETLW  FD
01A9:  RETLW  3D
01AA:  RETLW  FF
01AB:  RETLW  3F
01AC:  RETLW  3E
01AD:  RETLW  FE
01AE:  RETLW  FA
01AF:  RETLW  3A
01B0:  RETLW  3B
01B1:  RETLW  FB
01B2:  RETLW  39
01B3:  RETLW  F9
01B4:  RETLW  F8
01B5:  RETLW  38
01B6:  RETLW  28
01B7:  RETLW  E8
01B8:  RETLW  E9
01B9:  RETLW  29
01BA:  RETLW  EB
01BB:  RETLW  2B
01BC:  RETLW  2A
01BD:  RETLW  EA
01BE:  RETLW  EE
01BF:  RETLW  2E
01C0:  RETLW  2F
01C1:  RETLW  EF
01C2:  RETLW  2D
01C3:  RETLW  ED
01C4:  RETLW  EC
01C5:  RETLW  2C
01C6:  RETLW  E4
01C7:  RETLW  24
01C8:  RETLW  25
01C9:  RETLW  E5
01CA:  RETLW  27
01CB:  RETLW  E7
01CC:  RETLW  E6
01CD:  RETLW  26
01CE:  RETLW  22
01CF:  RETLW  E2
01D0:  RETLW  E3
01D1:  RETLW  23
01D2:  RETLW  E1
01D3:  RETLW  21
01D4:  RETLW  20
01D5:  RETLW  E0
01D6:  RETLW  A0
01D7:  RETLW  60
01D8:  RETLW  61
01D9:  RETLW  A1
01DA:  RETLW  63
01DB:  RETLW  A3
01DC:  RETLW  A2
01DD:  RETLW  62
01DE:  RETLW  66
01DF:  RETLW  A6
01E0:  RETLW  A7
01E1:  RETLW  67
01E2:  RETLW  A5
01E3:  RETLW  65
01E4:  RETLW  64
01E5:  RETLW  A4
01E6:  RETLW  6C
01E7:  RETLW  AC
01E8:  RETLW  AD
01E9:  RETLW  6D
01EA:  RETLW  AF
01EB:  RETLW  6F
01EC:  RETLW  6E
01ED:  RETLW  AE
01EE:  RETLW  AA
01EF:  RETLW  6A
01F0:  RETLW  6B
01F1:  RETLW  AB
01F2:  RETLW  69
01F3:  RETLW  A9
01F4:  RETLW  A8
01F5:  RETLW  68
01F6:  RETLW  78
01F7:  RETLW  B8
01F8:  RETLW  B9
01F9:  RETLW  79
01FA:  RETLW  BB
01FB:  RETLW  7B
01FC:  RETLW  7A
01FD:  RETLW  BA
01FE:  RETLW  BE
01FF:  RETLW  7E
0200:  RETLW  7F
0201:  RETLW  BF
0202:  RETLW  7D
0203:  RETLW  BD
0204:  RETLW  BC
0205:  RETLW  7C
0206:  RETLW  B4
0207:  RETLW  74
0208:  RETLW  75
0209:  RETLW  B5
020A:  RETLW  77
020B:  RETLW  B7
020C:  RETLW  B6
020D:  RETLW  76
020E:  RETLW  72
020F:  RETLW  B2
0210:  RETLW  B3
0211:  RETLW  73
0212:  RETLW  B1
0213:  RETLW  71
0214:  RETLW  70
0215:  RETLW  B0
0216:  RETLW  50
0217:  RETLW  90
0218:  RETLW  91
0219:  RETLW  51
021A:  RETLW  93
021B:  RETLW  53
021C:  RETLW  52
021D:  RETLW  92
021E:  RETLW  96
021F:  RETLW  56
0220:  RETLW  57
0221:  RETLW  97
0222:  RETLW  55
0223:  RETLW  95
0224:  RETLW  94
0225:  RETLW  54
0226:  RETLW  9C
0227:  RETLW  5C
0228:  RETLW  5D
0229:  RETLW  9D
022A:  RETLW  5F
022B:  RETLW  9F
022C:  RETLW  9E
022D:  RETLW  5E
022E:  RETLW  5A
022F:  RETLW  9A
0230:  RETLW  9B
0231:  RETLW  5B
0232:  RETLW  99
0233:  RETLW  59
0234:  RETLW  58
0235:  RETLW  98
0236:  RETLW  88
0237:  RETLW  48
0238:  RETLW  49
0239:  RETLW  89
023A:  RETLW  4B
023B:  RETLW  8B
023C:  RETLW  8A
023D:  RETLW  4A
023E:  RETLW  4E
023F:  RETLW  8E
0240:  RETLW  8F
0241:  RETLW  4F
0242:  RETLW  8D
0243:  RETLW  4D
0244:  RETLW  4C
0245:  RETLW  8C
0246:  RETLW  44
0247:  RETLW  84
0248:  RETLW  85
0249:  RETLW  45
024A:  RETLW  87
024B:  RETLW  47
024C:  RETLW  46
024D:  RETLW  86
024E:  RETLW  82
024F:  RETLW  42
0250:  RETLW  43
0251:  RETLW  83
0252:  RETLW  41
0253:  RETLW  81
0254:  RETLW  80
0255:  RETLW  40
0256:  INCF   6F,F
*
02FD:  DATA CD,37
02FE:  DATA 64,31
02FF:  DATA F5,39
0300:  DATA 20,29
0301:  DATA 73,1A
0302:  DATA B8,1A
0303:  DATA 20,29
0304:  DATA D4,2A
0305:  DATA 20,05
0306:  DATA 00,00
0307:  DATA C3,3A
0308:  DATA 72,39
0309:  DATA 65,37
030A:  DATA 74,1D
030B:  DATA 20,00
030C:  DATA 0D,05
030D:  DATA 0D,05
030E:  DATA 00,01
030F:  DATA BC,16
0310:  DATA 2A,15
0311:  DATA 45,3C
0312:  DATA E3,32
0313:  DATA 70,3A
0314:  DATA E9,37
0315:  DATA 6E,10
0316:  DATA 25,2C
0317:  DATA 2A,15
0318:  DATA 2D,1F
0319:  DATA 0D,05
031A:  DATA 0D,05
031B:  DATA 00,00
031C:  DATA 55,37
031D:  DATA 69,3A
031E:  DATA 3A,10
031F:  DATA 00,01
0320:  DATA 0D,05
0321:  DATA 0D,05
0322:  DATA 00,01
0323:  DATA BC,16
0324:  DATA 2A,15
0325:  DATA 45,3C
0326:  DATA E3,32
0327:  DATA 70,3A
0328:  DATA E9,37
0329:  DATA 6E,10
032A:  DATA 25,2C
032B:  DATA 2A,15
032C:  DATA 2D,1F
032D:  DATA 0D,05
032E:  DATA 0D,05
032F:  DATA 00,01
0330:  DATA D0,37
0331:  DATA F7,32
0332:  DATA 72,1D
0333:  DATA 20,00
0334:  DATA 0D,05
0335:  DATA 0D,05
0336:  DATA 00,01
0337:  DATA BC,16
0338:  DATA 2A,15
0339:  DATA 45,3C
033A:  DATA E3,32
033B:  DATA 70,3A
033C:  DATA E9,37
033D:  DATA 6E,10
033E:  DATA 25,2C
033F:  DATA 2A,15
0340:  DATA 2D,1F
0341:  DATA 0D,05
0342:  DATA 0D,05
0343:  DATA 00,01
0344:  DATA D6,37
0345:  DATA 6C,3A
0346:  DATA E1,33
0347:  DATA 65,1D
0348:  DATA 20,00
0349:  DATA 0D,05
034A:  DATA 0D,05
034B:  DATA 00,01
034C:  DATA BC,16
034D:  DATA 2A,15
034E:  DATA 45,3C
034F:  DATA E3,32
0350:  DATA 70,3A
0351:  DATA E9,37
0352:  DATA 6E,10
0353:  DATA 25,2C
0354:  DATA 2A,15
0355:  DATA 2D,1F
0356:  DATA 0D,05
0357:  DATA 0D,05
0358:  DATA 00,00
*
036C:  MOVF   0B,W
036D:  BCF    0B.7
036E:  MOVLB  10
036F:  BCF    1E.6
0370:  BSF    1E.0
0371:  NOP
0372:  NOP
0373:  BTFSC  09.7
0374:  BSF    0B.7
0375:  MOVF   1C,W
0376:  ANDLW  7F
0377:  BTFSC  03.2
0378:  GOTO   3BC
0379:  MOVLB  01
037A:  MOVWF  2B
037B:  MOVLB  10
037C:  MOVF   1A,W
037D:  MOVLB  01
037E:  MOVWF  2C
037F:  MOVLB  10
0380:  MOVF   1B,W
0381:  MOVLB  01
0382:  MOVWF  2D
0383:  MOVF   2B,W
0384:  MOVLB  0E
0385:  BTFSS  0F.4
0386:  GOTO   385
0387:  MOVLB  02
0388:  MOVWF  1A
0389:  MOVLB  01
038A:  MOVF   2C,W
038B:  MOVLB  10
038C:  MOVWF  1A
038D:  MOVLB  01
038E:  MOVF   2D,W
038F:  MOVLB  10
0390:  MOVWF  1B
0391:  MOVF   0B,W
0392:  BCF    0B.7
0393:  BCF    1E.6
0394:  BSF    1E.0
0395:  NOP
0396:  NOP
0397:  BTFSC  09.7
0398:  BSF    0B.7
0399:  RLF    1C,W
039A:  RLF    1D,W
039B:  ANDLW  7F
039C:  BTFSC  03.2
039D:  GOTO   3BC
039E:  MOVLB  01
039F:  MOVWF  2B
03A0:  MOVLB  10
03A1:  MOVF   1A,W
03A2:  MOVLB  01
03A3:  MOVWF  2C
03A4:  MOVLB  10
03A5:  MOVF   1B,W
03A6:  MOVLB  01
03A7:  MOVWF  2D
03A8:  MOVF   2B,W
03A9:  MOVLB  0E
03AA:  BTFSS  0F.4
03AB:  GOTO   3AA
03AC:  MOVLB  02
03AD:  MOVWF  1A
03AE:  MOVLB  01
03AF:  MOVF   2C,W
03B0:  MOVLB  10
03B1:  MOVWF  1A
03B2:  MOVLB  01
03B3:  MOVF   2D,W
03B4:  MOVLB  10
03B5:  MOVWF  1B
03B6:  INCF   1A,F
03B7:  BTFSC  03.2
03B8:  INCF   1B,F
03B9:  MOVLB  00
03BA:  GOTO   36C
03BB:  MOVLB  10
03BC:  MOVLB  00
03BD:  RETURN
*
0525:  MOVLB  01
0526:  BTFSC  2B.7
0527:  GOTO   53C
0528:  MOVLW  0F
0529:  MOVWF  77
052A:  SWAPF  2A,W
052B:  ANDWF  77,F
052C:  MOVLW  0A
052D:  SUBWF  77,W
052E:  BTFSC  03.0
052F:  GOTO   533
0530:  MOVLW  30
0531:  ADDWF  77,F
0532:  GOTO   535
0533:  MOVF   2B,W
0534:  ADDWF  77,F
0535:  MOVF   77,W
0536:  MOVLB  0E
0537:  BTFSS  0F.4
0538:  GOTO   537
0539:  MOVLB  02
053A:  MOVWF  1A
053B:  MOVLB  01
053C:  MOVLW  0F
053D:  ANDWF  2A,F
053E:  MOVLW  0A
053F:  SUBWF  2A,W
0540:  BTFSC  03.0
0541:  GOTO   544
0542:  MOVLW  30
0543:  GOTO   546
0544:  BCF    2B.7
0545:  MOVF   2B,W
0546:  ADDWF  2A,F
0547:  MOVF   2A,W
0548:  MOVLB  0E
0549:  BTFSS  0F.4
054A:  GOTO   549
054B:  MOVLB  02
054C:  MOVWF  1A
054D:  MOVLB  00
054E:  RETURN
054F:  MOVF   0B,W
0550:  BCF    0B.7
0551:  MOVLB  10
0552:  BCF    1E.6
0553:  BSF    1E.0
0554:  NOP
0555:  NOP
0556:  BTFSC  09.7
0557:  BSF    0B.7
0558:  BTFSC  03.0
0559:  GOTO   584
055A:  MOVF   1C,W
055B:  ANDLW  7F
055C:  MOVLB  01
055D:  MOVWF  2B
055E:  MOVLB  10
055F:  MOVF   1A,W
0560:  MOVLB  01
0561:  MOVWF  2C
0562:  MOVLB  10
0563:  MOVF   1B,W
0564:  MOVLB  01
0565:  MOVWF  2D
0566:  MOVF   2B,W
0567:  MOVLB  0E
0568:  BTFSS  0F.4
0569:  GOTO   568
056A:  MOVLB  02
056B:  MOVWF  1A
056C:  MOVLB  01
056D:  MOVF   2C,W
056E:  MOVLB  10
056F:  MOVWF  1A
0570:  MOVLB  01
0571:  MOVF   2D,W
0572:  MOVLB  10
0573:  MOVWF  1B
0574:  MOVF   0B,W
0575:  BCF    0B.7
0576:  BCF    1E.6
0577:  BSF    1E.0
0578:  NOP
0579:  NOP
057A:  BTFSC  09.7
057B:  BSF    0B.7
057C:  MOVLB  01
057D:  DECFSZ 29,F
057E:  GOTO   580
057F:  GOTO   582
0580:  MOVLB  10
0581:  GOTO   584
0582:  GOTO   5A9
0583:  MOVLB  10
0584:  RLF    1C,W
0585:  RLF    1D,W
0586:  ANDLW  7F
0587:  MOVLB  01
0588:  MOVWF  2B
0589:  MOVLB  10
058A:  MOVF   1A,W
058B:  MOVLB  01
058C:  MOVWF  2C
058D:  MOVLB  10
058E:  MOVF   1B,W
058F:  MOVLB  01
0590:  MOVWF  2D
0591:  MOVF   2B,W
0592:  MOVLB  0E
0593:  BTFSS  0F.4
0594:  GOTO   593
0595:  MOVLB  02
0596:  MOVWF  1A
0597:  MOVLB  01
0598:  MOVF   2C,W
0599:  MOVLB  10
059A:  MOVWF  1A
059B:  MOVLB  01
059C:  MOVF   2D,W
059D:  MOVLB  10
059E:  MOVWF  1B
059F:  INCF   1A,F
05A0:  BTFSC  03.2
05A1:  INCF   1B,F
05A2:  BCF    03.0
05A3:  MOVLB  01
05A4:  DECFSZ 29,F
05A5:  GOTO   5A7
05A6:  GOTO   5A9
05A7:  MOVLB  00
05A8:  GOTO   54F
05A9:  MOVLB  00
05AA:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16 
....................  
.................... #FUSES BROWNOUT // brownout reset 
.................... #FUSES BORV24 
.................... #FUSES LVP  
....................  
.................... #use delay(internal=8000000) 
*
03BE:  MOVLW  20
03BF:  MOVWF  05
03C0:  MOVLW  60
03C1:  MOVWF  04
03C2:  MOVF   00,W
03C3:  BTFSC  03.2
03C4:  GOTO   3D2
03C5:  MOVLW  02
03C6:  MOVWF  78
03C7:  CLRF   77
03C8:  DECFSZ 77,F
03C9:  GOTO   3C8
03CA:  DECFSZ 78,F
03CB:  GOTO   3C7
03CC:  MOVLW  97
03CD:  MOVWF  77
03CE:  DECFSZ 77,F
03CF:  GOTO   3CE
03D0:  DECFSZ 00,F
03D1:  GOTO   3C5
03D2:  RETURN
03D3:  MOVLW  08
03D4:  MOVLB  01
03D5:  SUBWF  32,F
03D6:  BTFSS  03.0
03D7:  GOTO   3E5
03D8:  MOVLW  20
03D9:  MOVWF  05
03DA:  MOVLW  62
03DB:  MOVWF  04
03DC:  BCF    03.0
03DD:  RRF    00,F
03DE:  MOVF   00,W
03DF:  BTFSC  03.2
03E0:  GOTO   3E5
03E1:  GOTO   3E3
03E2:  NOP
03E3:  DECFSZ 00,F
03E4:  GOTO   3E2
03E5:  MOVLB  00
03E6:  RETURN
.................... #PIN_SELECT U1RX=PIN_C5 
.................... #PIN_SELECT U1TX=PIN_C4 
.................... #use rs232(baud=115200, UART1, ERRORS, stream=PORT1) 
....................  
.................... //!#use rs232(baud=9600,parity=N,xmit=PIN_C4,rcv=PIN_C5,bits=8,stream=PORT1) 
....................  
.................... #PIN_SELECT U2RX=PIN_C6 
.................... #PIN_SELECT U2TX=PIN_C7 
....................  
.................... //!#include <main.h> 
.................... #define MODBUS_BUS SERIAL 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA2 
.................... #define MODBUS_PARITY "NONE" 
.................... #define MODBUS_SERIAL_RX_PIN PIN_C6 
.................... #define MODBUS_SERIAL_TX_PIN PIN_C7 
.................... #define MODBUS_SERIAL_BAUD 2400 
.................... //!#define MODBUS_REMOTE_ADDRESS 0x01 
.................... #include "modbus.c" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.c                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... ////  How to Use:                                                                     //// 
.................... ////                                                                                  //// 
.................... ////  Include just this file, modbus.c, in your main program. Before including this   //// 
.................... ////  file define the constants below for your needs.                                 //// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <modbus.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.h                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2010 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_H 
.................... #define MODBUS_H 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_PROTOCOL_SERIAL 0 
.................... #define MODBUS_PROTOCOL_TCPIP  100 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_TYPE_CLIENT 20 
.................... #define MODBUS_TYPE_SERVER 21 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
.................... #define MODBUS_TIMER_NOISR 13 
.................... #define MODBUS_TIMER_ISR   12 
.................... #define MODBUS_TIMER_T1    14 
.................... #define MODBUS_TIMER_T2    15 
....................  
.................... #ifndef MODBUS_PROTOCOL 
....................  #define MODBUS_PROTOCOL MODBUS_PROTOCOL_SERIAL 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE MODBUS_TYPE_MASTER 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TYPE 
....................   #define MODBUS_SERIAL_TYPE MODBUS_RTU 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_INT_SOURCE 
....................   #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA   // Select between external interrupt 
....................  #endif                                             // or asynchronous serial interrupt 
....................  
....................  #ifndef MODBUS_SERIAL_BAUD 
....................   #define MODBUS_SERIAL_BAUD 9600 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_PIN 
....................   #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TX_PIN 
....................   #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_ENABLE_PIN 
....................   #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_ENABLE 
....................   #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
....................  #endif 
....................  
....................  #ifndef MODBUS_PARITY 
....................   #define MODBUS_PARITY "EVEN" 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TIMEOUT 
....................   #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................    #define MODBUS_SERIAL_TIMEOUT    1000000 
....................   #else 
....................    #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
....................   #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_UPDATE 
....................   #define MODBUS_TIMER_UPDATE MODBUS_TIMER_ISR 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_USED 
....................   #define MODBUS_TIMER_USED MODBUS_TIMER_T1 
....................  #endif 
....................  
.................... #else ///////////////////////// MODBUS TCP/IP PROTOCOL ///////////////////////// 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE   MODBUS_TYPE_CLIENT 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_LISTEN_PORT 
....................   #define MODBUS_SERVER_LISTEN_PORT    502   //this is the default listen port for MODBUS TCP/IP protocol 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_SERVER) 
....................   #ifndef MODBUS_LISTEN_SOCKETS 
....................    #define MODBUS_LISTEN_SOCKETS     1 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_BUFFER_SIZE 
....................   #define MODBUS_BUFFER_SIZE   64 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_TIMEOUT 
....................   #define MODBUS_SERVER_TIMEOUT  5  //time in seconds that client will wait for server response before timeout 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_CLIENT) 
....................   #ifndef MODBUS_SERVER_ADDR_0 
....................    #define MODBUS_SERVER_ADDR_0  192 
....................    #define MODBUS_SERVER_ADDR_1  168 
....................    #define MODBUS_SERVER_ADDR_2  100 
....................    #define MODBUS_SERVER_ADDR_3  140 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef debug_printf 
....................   #define debug_printf(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  #endif 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_phy_layer_tcpip.h> 
.................... #else 
....................  #include <modbus_phy_layer.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sfr_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_app_layer_tcpip.h> 
.................... #else 
....................  #include <modbus_app_layer.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include <modbus_phy_layer.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sfr_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
.................... #endif 
....................  
.................... #endif //MODBUS_H 
....................  
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................   #include <modbus_phy_layer_rtu.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                              modbus_phy_layer_rtu.c                              //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_RTU_C 
.................... #define MODBUS_PHY_LAYER_RTU_C 
....................  
.................... #include <modbus_phy_layer.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sfr_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... #if (MODBUS_TIMER_USED == MODBUS_TIMER_T1) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #use TIMER(TIMER=1,TICK=.1ms,BITS=16, ISR) 
*
026F:  MOVLB  01
0270:  MOVF   39,W
0271:  MOVWF  77
0272:  MOVF   3A,W
0273:  MOVWF  78
0274:  CLRF   79
0275:  BCF    03.0
0276:  RLF    77,F
0277:  RLF    78,F
0278:  RLF    79,F
0279:  BCF    03.0
027A:  RLF    77,F
027B:  RLF    78,F
027C:  RLF    79,F
027D:  BCF    03.0
027E:  RLF    77,F
027F:  RLF    78,F
0280:  RLF    79,F
0281:  BCF    03.0
0282:  RLF    77,F
0283:  RLF    78,F
0284:  RLF    79,F
0285:  BCF    03.0
0286:  RLF    77,F
0287:  RLF    78,F
0288:  RLF    79,F
0289:  MOVF   79,W
028A:  MOVLB  00
028B:  MOVWF  6F
028C:  MOVF   78,W
028D:  MOVLB  04
028E:  MOVWF  0D
028F:  MOVF   77,W
0290:  MOVWF  0C
0291:  MOVLB  00
0292:  RETURN
*
0471:  MOVF   6F,W
0472:  MOVWF  78
0473:  MOVLB  04
0474:  MOVF   0D,W
0475:  MOVWF  7A
0476:  MOVF   0C,W
0477:  MOVWF  77
0478:  MOVF   0D,W
0479:  SUBWF  7A,W
047A:  BTFSS  03.2
047B:  GOTO   474
047C:  MOVF   77,W
047D:  MOVLB  0E
047E:  BCF    1A.0
047F:  MOVWF  79
0480:  MOVLB  00
0481:  MOVF   6F,W
0482:  SUBWF  78,W
0483:  BTFSC  03.2
0484:  GOTO   491
0485:  MOVLB  04
0486:  MOVF   0D,W
0487:  MOVWF  7A
0488:  MOVF   0C,W
0489:  MOVWF  77
048A:  MOVF   0D,W
048B:  SUBWF  7A,W
048C:  BTFSS  03.2
048D:  GOTO   486
048E:  MOVF   77,W
048F:  GOTO   493
0490:  MOVLB  00
0491:  MOVF   79,W
0492:  MOVLB  04
0493:  MOVWF  77
0494:  MOVF   7A,W
0495:  MOVWF  78
0496:  MOVLB  00
0497:  MOVF   6F,W
0498:  MOVWF  79
0499:  RRF    79,F
049A:  RRF    78,F
049B:  RRF    77,F
049C:  RRF    79,F
049D:  RRF    78,F
049E:  RRF    77,F
049F:  RRF    79,F
04A0:  RRF    78,F
04A1:  RRF    77,F
04A2:  RRF    79,F
04A3:  RRF    78,F
04A4:  RRF    77,F
04A5:  RRF    79,F
04A6:  RRF    78,F
04A7:  RRF    77,F
04A8:  MOVLB  0E
04A9:  BSF    1A.0
....................   #else 
....................     #use TIMER(TIMER=1,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #elif (MODBUS_TIMER_USED == MODBUS_TIMER_T2) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #use TIMER(TIMER=2,TICK=.1ms,BITS=16, ISR) 
....................   #else 
....................     #use TIMER(TIMER=2,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #endif 
....................  
.................... #define MODBUS_GETDATA_TIMEOUT 40 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) // Change default parity bit to 1 // before is 2 bits 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) // Change default parity bit to 1 // before is 2 bits 
*
025D:  MOVLB  0E
025E:  BTFSS  0F.7
025F:  GOTO   25E
0260:  MOVLB  14
0261:  MOVF   1D,W
0262:  MOVLB  00
0263:  MOVWF  29
0264:  MOVLB  14
0265:  MOVF   19,W
0266:  MOVWF  78
0267:  MOVLB  00
0268:  BTFSS  29.1
0269:  GOTO   26D
026A:  MOVLB  14
026B:  BCF    1D.4
026C:  BSF    1D.4
026D:  MOVLB  00
026E:  RETURN
*
03E9:  MOVLB  0E
03EA:  BTFSS  0F.6
03EB:  GOTO   3EA
03EC:  MOVLB  14
03ED:  MOVWF  1A
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, disable_ints) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, disable_ints) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................   #endif 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... /* status of between byte timeout */ 
.................... int1 modbus_timeout_enabled = false; 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... unsigned int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
.................... #endif 
....................  
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    unsigned int8 b[2]; 
....................    unsigned int16 d; 
.................... } modbus_serial_crc; 
....................  
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const unsigned char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
0359:  MOVLB  0E
035A:  BTFSS  0F.7
035B:  GOTO   360
035C:  MOVLB  00
035D:  CALL   25D
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................          clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
035E:  GOTO   359
035F:  MOVLB  0E
....................          clear_interrupt(INT_RDA2); 
0360:  MOVLB  14
0361:  MOVF   19,W
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................          clear_interrupt(INT_RDA3); 
....................       #else 
....................          clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
0362:  MOVLB  0E
0363:  BSF    19.7
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
0364:  MOVLB  00
0365:  RETURN
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................  
....................       ext_int_edge(H_TO_L); 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    modbus_timeout_enabled = enable; 
*
0293:  BCF    2A.1
0294:  MOVLB  01
0295:  BTFSS  38.0
0296:  GOTO   29A
0297:  MOVLB  00
0298:  BSF    2A.1
0299:  MOVLB  01
....................    set_ticks(0); 
029A:  CLRF   3A
029B:  CLRF   39
029C:  MOVLB  00
029D:  CALL   26F
029E:  RETURN
.................... } 
....................  
.................... // Purpose:    Handles a timeout when waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
*
04B8:  MOVF   70,W
04B9:  SUBLW  02
04BA:  BTFSS  03.2
04BB:  GOTO   4CC
04BC:  MOVF   24,F
04BD:  BTFSS  03.2
04BE:  GOTO   4CC
04BF:  MOVF   25,F
04C0:  BTFSS  03.2
04C1:  GOTO   4CC
04C2:  MOVLB  00
04C3:  BTFSS  2A.0
04C4:  GOTO   4C7
04C5:  MOVLB  01
04C6:  GOTO   4CC
....................    { 
....................       modbus_rx.len-=2; 
04C7:  MOVLW  02
04C8:  SUBWF  2C,F
....................       modbus_serial_new=TRUE; 
04C9:  BSF    2A.0
....................    } else { 
04CA:  GOTO   4CE
04CB:  MOVLB  01
....................       modbus_serial_new=FALSE; 
04CC:  MOVLB  00
04CD:  BCF    2A.0
....................    } 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
04CE:  MOVLW  FF
04CF:  MOVLB  01
04D0:  MOVWF  25
04D1:  MOVWF  24
....................    modbus_serial_state=MODBUS_GETADDY; 
04D2:  CLRF   70
04D3:  MOVLB  00
04D4:  CLRF   28
04D5:  BTFSC  0B.7
04D6:  BSF    28.7
04D7:  BCF    0B.7
....................    modbus_enable_timeout(FALSE); 
04D8:  MOVLB  01
04D9:  CLRF   38
04DA:  MOVLB  00
04DB:  CALL   293
04DC:  BTFSC  28.7
04DD:  BSF    0B.7
.................... } 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_check_timeout(void) 
.................... { 
....................    #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_NOISR) 
....................    //get_ticks() must be called more often than the timer overflow 
....................    //rate, and the get_ticks() below will not always be called 
....................    //due to short circuit evaluation 
....................    get_ticks(); 
....................    #endif 
....................    //modbus_timeout_enabled must be checked before get_ticks() 
....................    //so that if an interrupt happens it cannot be enabled after 
....................    //an old timer value is used in comparison 
....................    if(modbus_timeout_enabled && (get_ticks() > MODBUS_GETDATA_TIMEOUT)) 
*
046E:  MOVLB  00
046F:  BTFSS  2A.1
0470:  GOTO   4DE
*
04AA:  MOVF   78,W
04AB:  MOVLB  01
04AC:  MOVWF  2F
04AD:  MOVF   77,W
04AE:  MOVWF  2E
04AF:  MOVF   2F,F
04B0:  BTFSS  03.2
04B1:  GOTO   4B8
04B2:  MOVF   2E,W
04B3:  SUBLW  28
04B4:  BTFSS  03.0
04B5:  GOTO   4B8
04B6:  MOVLB  00
04B7:  GOTO   4DE
....................    { 
....................      modbus_timeout_now(); 
....................    } 
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_calc_crc(char data) 
.................... { 
....................    unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................    uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
029F:  MOVLB  01
02A0:  MOVF   25,W
02A1:  XORWF  38,W
02A2:  MOVWF  39
....................    modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
02A3:  MOVF   39,W
02A4:  MOVLB  00
02A5:  CALL   054
02A6:  MOVWF  78
02A7:  MOVLB  01
02A8:  MOVF   24,W
02A9:  XORWF  78,W
02AA:  MOVWF  25
....................    modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
02AB:  MOVF   39,W
02AC:  MOVLB  00
02AD:  CALL   155
02AE:  MOVWF  78
02AF:  MOVLB  01
02B0:  MOVWF  24
02B1:  MOVLB  00
02B2:  RETURN
.................... } 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c) 
.................... { 
....................    fputc(c, MODBUS_SERIAL); 
*
03E7:  MOVLB  01
03E8:  MOVF   30,W
*
03EE:  MOVLB  00
03EF:  CLRF   28
03F0:  BTFSC  0B.7
03F1:  BSF    28.7
03F2:  BCF    0B.7
....................    modbus_calc_crc(c); 
03F3:  MOVLB  01
03F4:  MOVF   30,W
03F5:  MOVWF  38
03F6:  MOVLB  00
03F7:  CALL   29F
03F8:  BTFSC  28.7
03F9:  BSF    0B.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
03FA:  MOVLW  02
03FB:  MOVLB  01
03FC:  MOVWF  31
03FD:  MOVLW  CE
03FE:  MOVWF  32
03FF:  MOVLB  00
0400:  CALL   3D3
0401:  MOVLB  01
0402:  DECFSZ 31,F
0403:  GOTO   3FD
0404:  MOVLB  00
0405:  RETURN
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
*
040B:  MOVLW  FF
040C:  MOVWF  25
040D:  MOVWF  24
....................    modbus_serial_new=FALSE; 
040E:  MOVLB  00
040F:  BCF    2A.0
....................  
....................    RCV_OFF(); 
0410:  MOVLB  0E
0411:  BCF    19.7
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
0412:  MOVLW  01
0413:  MOVLB  01
0414:  MOVWF  30
0415:  MOVLB  00
0416:  CALL   3BE
0417:  MOVLW  02
0418:  MOVLB  01
0419:  MOVWF  30
041A:  MOVLW  E3
041B:  MOVWF  32
041C:  MOVLB  00
041D:  CALL   3D3
041E:  MOVLB  01
041F:  DECFSZ 30,F
0420:  GOTO   41A
....................  
....................    modbus_serial_putc(to); 
0421:  MOVF   2E,W
0422:  MOVWF  30
0423:  MOVLB  00
0424:  CALL   3E7
....................    modbus_serial_putc(func); 
0425:  MOVLB  01
0426:  MOVF   2F,W
0427:  MOVWF  30
0428:  MOVLB  00
0429:  CALL   3E7
.................... } 
....................  
.................... // Purpose:    Ends a message over the RS485 Bus 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop() 
.................... { 
....................    unsigned int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
*
0442:  MOVLB  01
0443:  MOVF   25,W
0444:  MOVWF  2F
....................    crc_low=modbus_serial_crc.b[0]; 
0445:  MOVF   24,W
0446:  MOVWF  2E
....................  
....................    modbus_serial_putc(crc_high); 
0447:  MOVF   2F,W
0448:  MOVWF  30
0449:  MOVLB  00
044A:  CALL   3E7
....................    modbus_serial_putc(crc_low); 
044B:  MOVLB  01
044C:  MOVF   2E,W
044D:  MOVWF  30
044E:  MOVLB  00
044F:  CALL   3E7
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
0450:  MOVLB  14
0451:  BTFSS  1E.1
0452:  GOTO   451
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
0453:  MOVLW  01
0454:  MOVLB  01
0455:  MOVWF  30
0456:  MOVLB  00
0457:  CALL   3BE
0458:  MOVLW  02
0459:  MOVLB  01
045A:  MOVWF  30
045B:  MOVLW  E3
045C:  MOVWF  32
045D:  MOVLB  00
045E:  CALL   3D3
045F:  MOVLB  01
0460:  DECFSZ 30,F
0461:  GOTO   45B
....................  
....................    RCV_ON(); 
0462:  MOVLB  00
0463:  CALL   359
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... #endif 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
0464:  MOVLW  FF
0465:  MOVLB  01
0466:  MOVWF  25
0467:  MOVWF  24
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Interrupts                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext1 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
02B3:  CALL   25D
02B4:  MOVF   78,W
02B5:  MOVLB  01
02B6:  MOVWF  36
....................  
....................    if (!modbus_serial_new) 
02B7:  MOVLB  00
02B8:  BTFSC  2A.0
02B9:  GOTO   2F0
....................    { 
....................       if(modbus_serial_state == MODBUS_GETADDY) 
02BA:  MOVF   70,F
02BB:  BTFSS  03.2
02BC:  GOTO   2C8
....................       { 
....................          modbus_serial_crc.d = 0xFFFF; 
02BD:  MOVLW  FF
02BE:  MOVLB  01
02BF:  MOVWF  25
02C0:  MOVWF  24
....................          modbus_rx.address = c; 
02C1:  MOVF   36,W
02C2:  MOVLB  00
02C3:  MOVWF  2B
....................          modbus_serial_state++; 
02C4:  INCF   70,F
....................          modbus_rx.len = 0; 
02C5:  CLRF   2C
....................          modbus_rx.error=0; 
02C6:  CLRF   2E
....................       } 
02C7:  GOTO   2E6
....................       else if(modbus_serial_state == MODBUS_GETFUNC) 
02C8:  DECFSZ 70,W
02C9:  GOTO   2D0
....................       { 
....................          modbus_rx.func = c; 
02CA:  MOVLB  01
02CB:  MOVF   36,W
02CC:  MOVLB  00
02CD:  MOVWF  2D
....................          modbus_serial_state++; 
02CE:  INCF   70,F
....................       } 
02CF:  GOTO   2E6
....................       else if(modbus_serial_state == MODBUS_GETDATA) 
02D0:  MOVF   70,W
02D1:  SUBLW  02
02D2:  BTFSS  03.2
02D3:  GOTO   2E6
....................       { 
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
02D4:  MOVF   2C,W
02D5:  SUBLW  3F
02D6:  BTFSC  03.0
02D7:  GOTO   2DA
....................        { 
....................          modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
02D8:  MOVLW  3F
02D9:  MOVWF  2C
....................        } 
....................          modbus_rx.data[modbus_rx.len]=c; 
02DA:  MOVLW  0F
02DB:  ADDWF  2C,W
02DC:  MOVWF  04
02DD:  MOVLW  20
02DE:  MOVWF  05
02DF:  BTFSC  03.0
02E0:  INCF   05,F
02E1:  MOVLB  01
02E2:  MOVF   36,W
02E3:  MOVWF  00
....................          modbus_rx.len++; 
02E4:  MOVLB  00
02E5:  INCF   2C,F
....................      } 
....................      modbus_enable_timeout(TRUE); 
02E6:  MOVLW  01
02E7:  MOVLB  01
02E8:  MOVWF  38
02E9:  MOVLB  00
02EA:  CALL   293
....................      modbus_calc_crc(c); 
02EB:  MOVLB  01
02EC:  MOVF   36,W
02ED:  MOVWF  38
02EE:  MOVLB  00
02EF:  CALL   29F
....................    } 
....................  
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
02F0:  MOVLB  01
02F1:  CLRF   23
02F2:  CLRF   22
02F3:  MOVLW  27
02F4:  MOVWF  21
02F5:  MOVLW  10
02F6:  MOVWF  20
....................    #endif 
.................... } 
.................... #endif //MODBUS_PHY_LAYER_RTU_C 
....................  
....................  #elif (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................   #include <modbus_phy_layer_ascii.c> 
....................  #endif 
.................... #else 
....................  #include <modbus_phy_layer_tcpip.c> 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include <modbus_app_layer_tcpip.c> 
.................... #else 
....................  #include <modbus_app_layer.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.c                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_C 
.................... #define MODBUS_APP_LAYER_C 
....................  
.................... #include <modbus_app_layer.h> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
02F7:  MOVLB  0E
02F8:  BCF    0F.7
02F9:  MOVLB  00
02FA:  MOVLP  00
02FB:  MOVLB  00
02FC:  GOTO   037
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include <modbus_phy_layer.h> 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared Api                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
*
0366:  BCF    00.0
....................  
....................    RCV_ON(); 
0367:  CALL   359
....................  
....................    #if defined(__PCD__) 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       enable_interrupts(GLOBAL); 
0368:  MOVLW  C0
0369:  IORWF  0B,F
....................    #endif 
036A:  MOVLP  00
036B:  GOTO   609 (RETURN)
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    #if(MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    modbus_check_timeout(); 
....................    #endif 
....................  
....................    if(!modbus_serial_new) 
*
04DE:  BTFSC  2A.0
04DF:  GOTO   4E4
....................      return FALSE; 
04E0:  MOVLW  00
04E1:  MOVWF  78
04E2:  GOTO   4ED
04E3:  GOTO   4EA
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
04E4:  BTFSS  2D.7
04E5:  GOTO   4EA
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
04E6:  MOVF   2F,W
04E7:  MOVWF  2E
....................       modbus_rx.len = 1; 
04E8:  MOVLW  01
04E9:  MOVWF  2C
....................    } 
....................    modbus_serial_new=FALSE; 
04EA:  BCF    2A.0
....................    return TRUE; 
04EB:  MOVLW  01
04EC:  MOVWF  78
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master API                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
*
0406:  MOVLB  01
0407:  MOVF   29,W
0408:  MOVWF  2E
0409:  MOVLW  04
040A:  MOVWF  2F
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
*
042A:  MOVLB  01
042B:  MOVF   2B,W
042C:  MOVWF  2E
042D:  MOVWF  30
042E:  MOVLB  00
042F:  CALL   3E7
....................    modbus_serial_putc(make8(start_address,0)); 
0430:  MOVLB  01
0431:  MOVF   2A,W
0432:  MOVWF  2E
0433:  MOVWF  30
0434:  MOVLB  00
0435:  CALL   3E7
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0436:  MOVLB  01
0437:  MOVF   2D,W
0438:  MOVWF  2E
0439:  MOVWF  30
043A:  MOVLB  00
043B:  CALL   3E7
....................    modbus_serial_putc(make8(quantity,0)); 
043C:  MOVLB  01
043D:  MOVF   2C,W
043E:  MOVWF  2E
043F:  MOVWF  30
0440:  MOVLB  00
0441:  CALL   3E7
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
*
0468:  MOVLB  00
0469:  BCF    2A.1
046A:  MOVLB  01
046B:  MOVF   29,F
046C:  BTFSC  03.2
046D:  GOTO   51B
*
04ED:  MOVF   78,F
04EE:  BTFSS  03.2
04EF:  GOTO   50A
04F0:  MOVLW  FF
04F1:  MOVLB  01
04F2:  ADDWF  20,F
04F3:  BTFSS  03.0
04F4:  ADDWF  21,F
04F5:  BTFSS  03.0
04F6:  ADDWF  22,F
04F7:  BTFSS  03.0
04F8:  ADDWF  23,F
04F9:  MOVF   20,F
04FA:  BTFSS  03.2
04FB:  GOTO   507
04FC:  MOVF   21,F
04FD:  BTFSS  03.2
04FE:  GOTO   507
04FF:  MOVF   22,F
0500:  BTFSS  03.2
0501:  GOTO   507
0502:  MOVF   23,F
0503:  BTFSS  03.2
0504:  GOTO   507
0505:  MOVLB  00
0506:  GOTO   50A
0507:  GOTO   508
0508:  GOTO   46E
0509:  MOVLB  00
050A:  MOVLB  01
050B:  MOVF   20,F
050C:  BTFSS  03.2
050D:  GOTO   51B
050E:  MOVF   21,F
050F:  BTFSS  03.2
0510:  GOTO   51B
0511:  MOVF   22,F
0512:  BTFSS  03.2
0513:  GOTO   51B
0514:  MOVF   23,F
0515:  BTFSS  03.2
0516:  GOTO   51B
0517:  MOVLW  0C
0518:  MOVLB  00
0519:  MOVWF  2E
051A:  MOVLB  01
051B:  CLRF   23
051C:  CLRF   22
051D:  MOVLW  27
051E:  MOVWF  21
051F:  MOVLW  10
0520:  MOVWF  20
....................  
....................    return modbus_rx.error; 
0521:  MOVLB  00
0522:  MOVF   2E,W
0523:  MOVWF  78
0524:  RETURN
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = (unsigned int8)((quantity/8)); 
....................  
....................    if(quantity%8) 
....................       count++; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((unsigned int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
....................       modbus_serial_putc(make8(*reg_data,0)); 
....................       reg_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
....................       modbus_serial_putc(make8(*input_data,0)); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
....................    modbus_serial_putc(make8(output_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       func               function to respond to 
....................            exception   error              exception response to send 
.................... Output:    void 
.................... */ 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
....................    modbus_serial_putc(error); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... #endif 
.................... #endif //MODBUS_APP_LAYER_C 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define MODBUS_SLAVE_ADDRESS 0x01 
.................... #define Power_Address 12 
.................... #define Current_Address 6 
.................... #define Unit_Address 342 
.................... #define Voltage_Address 0 
....................  
.................... void main() 
*
05AB:  MOVLW  55
05AC:  MOVLB  3D
05AD:  MOVWF  0F
05AE:  MOVLW  AA
05AF:  MOVWF  0F
05B0:  BCF    0F.0
05B1:  MOVLW  15
05B2:  MOVWF  4B
05B3:  MOVLW  16
05B4:  MOVWF  4D
05B5:  MOVLW  0F
05B6:  MOVLB  3E
05B7:  MOVWF  24
05B8:  MOVLW  11
05B9:  MOVWF  27
05BA:  MOVLW  55
05BB:  MOVLB  3D
05BC:  MOVWF  0F
05BD:  MOVLW  AA
05BE:  MOVWF  0F
05BF:  BSF    0F.0
05C0:  MOVLB  11
05C1:  CLRF   12
05C2:  CLRF   0F
05C3:  CLRF   11
05C4:  MOVLW  03
05C5:  MOVWF  13
05C6:  MOVLW  60
05C7:  MOVWF  0D
05C8:  MOVLB  00
05C9:  CLRF   29
05CA:  MOVLB  02
05CB:  BSF    1F.3
05CC:  MOVLW  10
05CD:  MOVWF  1B
05CE:  MOVLW  00
05CF:  MOVWF  1C
05D0:  MOVLW  A6
05D1:  MOVWF  1E
05D2:  MOVLW  90
05D3:  MOVWF  1D
05D4:  MOVLB  00
05D5:  BCF    2A.0
05D6:  CLRF   6F
05D7:  MOVLW  01
05D8:  MOVLB  04
05D9:  MOVWF  11
05DA:  MOVLW  33
05DB:  MOVWF  0E
05DC:  CLRF   0F
05DD:  CLRF   10
05DE:  CLRF   0C
05DF:  CLRF   0D
05E0:  CLRF   0C
05E1:  MOVLB  0E
05E2:  BCF    10.0
05E3:  BSF    1A.0
05E4:  MOVLB  14
05E5:  BSF    1F.3
05E6:  MOVLW  40
05E7:  MOVWF  1B
05E8:  MOVLW  03
05E9:  MOVWF  1C
05EA:  MOVLW  A6
05EB:  MOVWF  1E
05EC:  MOVLW  90
05ED:  MOVWF  1D
05EE:  MOVLB  00
05EF:  BCF    2A.1
05F0:  MOVLB  01
05F1:  CLRF   23
05F2:  CLRF   22
05F3:  MOVLW  27
05F4:  MOVWF  21
05F5:  MOVLW  10
05F6:  MOVWF  20
05F7:  CLRF   70
05F8:  CLRF   27
05F9:  CLRF   26
05FA:  MOVLB  3E
05FB:  CLRF   38
05FC:  CLRF   43
05FD:  CLRF   4E
05FE:  MOVLB  13
05FF:  CLRF   11
0600:  CLRF   12
0601:  CLRF   13
0602:  CLRF   10
0603:  CLRF   15
0604:  CLRF   16
0605:  CLRF   17
0606:  CLRF   14
.................... { 
....................    int i; 
....................    modbus_init(); 
0607:  MOVLB  00
0608:  GOTO   366
....................    fprintf(PORT1,"Modbus Rs485 RTU \n"); 
0609:  MOVLW  FD
060A:  MOVLB  10
060B:  MOVWF  1A
060C:  MOVLW  02
060D:  MOVWF  1B
060E:  MOVLB  00
060F:  CALL   36C
....................    delay_ms(2000); 
0610:  MOVLW  08
0611:  MOVLB  01
0612:  MOVWF  29
0613:  MOVLW  FA
0614:  MOVWF  30
0615:  MOVLB  00
0616:  CALL   3BE
0617:  MOVLB  01
0618:  DECFSZ 29,F
0619:  GOTO   613
....................     
....................    while(TRUE) 
....................    { 
....................       delay_ms(200); 
061A:  MOVLW  C8
061B:  MOVWF  30
061C:  MOVLB  00
061D:  CALL   3BE
....................    
....................       if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,Current_Address,2))) 
061E:  MOVLW  01
061F:  MOVLB  01
0620:  MOVWF  29
0621:  CLRF   2B
0622:  MOVLW  06
0623:  MOVWF  2A
0624:  CLRF   2D
0625:  MOVLW  02
0626:  MOVWF  2C
0627:  MOVLB  00
0628:  CALL   406
0629:  MOVF   78,F
062A:  BTFSS  03.2
062B:  GOTO   65B
....................       { 
....................          printf("Current: "); 
062C:  MOVLW  07
062D:  MOVLB  10
062E:  MOVWF  1A
062F:  MOVLW  03
0630:  MOVWF  1B
0631:  MOVLB  00
0632:  CALL   36C
....................          /*Started at 1 since 0 is quantity of coils*/ 
....................          for(i=1; i < (modbus_rx.len); ++i){ 
0633:  MOVLW  01
0634:  MOVLB  01
0635:  MOVWF  28
0636:  MOVLB  00
0637:  MOVF   2C,W
0638:  MOVLB  01
0639:  SUBWF  28,W
063A:  BTFSC  03.0
063B:  GOTO   653
....................             /*BufferRegister[i-1] = modbus_rx.data[i]; //! Start Address 0*/ 
....................             printf("%X ", modbus_rx.data[i]); 
063C:  MOVLW  0F
063D:  ADDWF  28,W
063E:  MOVWF  04
063F:  MOVLW  20
0640:  MOVWF  05
0641:  BTFSC  03.0
0642:  INCF   05,F
0643:  MOVF   00,W
0644:  MOVWF  29
0645:  MOVWF  2A
0646:  MOVLW  37
0647:  MOVWF  2B
0648:  MOVLB  00
0649:  CALL   525
064A:  MOVLW  20
064B:  MOVLB  0E
064C:  BTFSS  0F.4
064D:  GOTO   64C
064E:  MOVLB  02
064F:  MOVWF  1A
0650:  MOVLB  01
0651:  INCF   28,F
0652:  GOTO   636
....................          } 
....................          printf("\r\n\r\n"); 
0653:  MOVLW  0C
0654:  MOVLB  10
0655:  MOVWF  1A
0656:  MOVLW  03
0657:  MOVWF  1B
0658:  MOVLB  00
0659:  CALL   36C
....................       } 
065A:  GOTO   678
....................       else 
....................       { 
....................          printf("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
065B:  MOVLW  0F
065C:  MOVLB  10
065D:  MOVWF  1A
065E:  MOVLW  03
065F:  MOVWF  1B
0660:  BCF    03.0
0661:  MOVLW  0E
0662:  MOVLB  01
0663:  MOVWF  29
0664:  MOVLB  00
0665:  CALL   54F
0666:  MOVF   2E,W
0667:  MOVLB  01
0668:  MOVWF  2A
0669:  MOVLW  37
066A:  MOVWF  2B
066B:  MOVLB  00
066C:  CALL   525
066D:  MOVLW  17
066E:  MOVLB  10
066F:  MOVWF  1A
0670:  MOVLW  03
0671:  MOVWF  1B
0672:  BCF    03.0
0673:  MOVLW  08
0674:  MOVLB  01
0675:  MOVWF  29
0676:  MOVLB  00
0677:  CALL   54F
....................       } 
....................            
....................       delay_ms(200); 
0678:  MOVLW  C8
0679:  MOVLB  01
067A:  MOVWF  30
067B:  MOVLB  00
067C:  CALL   3BE
....................        
....................       if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,Unit_Address,2))) 
067D:  MOVLW  01
067E:  MOVLB  01
067F:  MOVWF  29
0680:  MOVWF  2B
0681:  MOVLW  56
0682:  MOVWF  2A
0683:  CLRF   2D
0684:  MOVLW  02
0685:  MOVWF  2C
0686:  MOVLB  00
0687:  CALL   406
0688:  MOVF   78,F
0689:  BTFSS  03.2
068A:  GOTO   6BA
....................       { 
....................          printf("Unit: "); 
068B:  MOVLW  1C
068C:  MOVLB  10
068D:  MOVWF  1A
068E:  MOVLW  03
068F:  MOVWF  1B
0690:  MOVLB  00
0691:  CALL   36C
....................          /*Started at 1 since 0 is quantity of coils*/ 
....................          for(i=1; i < (modbus_rx.len); ++i){ 
0692:  MOVLW  01
0693:  MOVLB  01
0694:  MOVWF  28
0695:  MOVLB  00
0696:  MOVF   2C,W
0697:  MOVLB  01
0698:  SUBWF  28,W
0699:  BTFSC  03.0
069A:  GOTO   6B2
....................             /*BufferRegister[i+7] = modbus_rx.data[i]; //! Start Address 8*/ 
....................             printf("%X ", modbus_rx.data[i]); 
069B:  MOVLW  0F
069C:  ADDWF  28,W
069D:  MOVWF  04
069E:  MOVLW  20
069F:  MOVWF  05
06A0:  BTFSC  03.0
06A1:  INCF   05,F
06A2:  MOVF   00,W
06A3:  MOVWF  29
06A4:  MOVWF  2A
06A5:  MOVLW  37
06A6:  MOVWF  2B
06A7:  MOVLB  00
06A8:  CALL   525
06A9:  MOVLW  20
06AA:  MOVLB  0E
06AB:  BTFSS  0F.4
06AC:  GOTO   6AB
06AD:  MOVLB  02
06AE:  MOVWF  1A
06AF:  MOVLB  01
06B0:  INCF   28,F
06B1:  GOTO   695
....................          } 
....................          printf("\r\n\r\n"); 
06B2:  MOVLW  20
06B3:  MOVLB  10
06B4:  MOVWF  1A
06B5:  MOVLW  03
06B6:  MOVWF  1B
06B7:  MOVLB  00
06B8:  CALL   36C
....................       } 
06B9:  GOTO   6D7
....................       else 
....................       { 
....................          printf("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
06BA:  MOVLW  23
06BB:  MOVLB  10
06BC:  MOVWF  1A
06BD:  MOVLW  03
06BE:  MOVWF  1B
06BF:  BCF    03.0
06C0:  MOVLW  0E
06C1:  MOVLB  01
06C2:  MOVWF  29
06C3:  MOVLB  00
06C4:  CALL   54F
06C5:  MOVF   2E,W
06C6:  MOVLB  01
06C7:  MOVWF  2A
06C8:  MOVLW  37
06C9:  MOVWF  2B
06CA:  MOVLB  00
06CB:  CALL   525
06CC:  MOVLW  2B
06CD:  MOVLB  10
06CE:  MOVWF  1A
06CF:  MOVLW  03
06D0:  MOVWF  1B
06D1:  BCF    03.0
06D2:  MOVLW  08
06D3:  MOVLB  01
06D4:  MOVWF  29
06D5:  MOVLB  00
06D6:  CALL   54F
....................       } 
....................        
....................       delay_ms(200); 
06D7:  MOVLW  C8
06D8:  MOVLB  01
06D9:  MOVWF  30
06DA:  MOVLB  00
06DB:  CALL   3BE
....................        
....................       if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,Power_Address,2))) 
06DC:  MOVLW  01
06DD:  MOVLB  01
06DE:  MOVWF  29
06DF:  CLRF   2B
06E0:  MOVLW  0C
06E1:  MOVWF  2A
06E2:  CLRF   2D
06E3:  MOVLW  02
06E4:  MOVWF  2C
06E5:  MOVLB  00
06E6:  CALL   406
06E7:  MOVF   78,F
06E8:  BTFSS  03.2
06E9:  GOTO   719
....................       { 
....................          printf("Power: "); 
06EA:  MOVLW  30
06EB:  MOVLB  10
06EC:  MOVWF  1A
06ED:  MOVLW  03
06EE:  MOVWF  1B
06EF:  MOVLB  00
06F0:  CALL   36C
....................          /*Started at 1 since 0 is quantity of coils*/ 
....................          for(i=1; i < (modbus_rx.len); ++i){ 
06F1:  MOVLW  01
06F2:  MOVLB  01
06F3:  MOVWF  28
06F4:  MOVLB  00
06F5:  MOVF   2C,W
06F6:  MOVLB  01
06F7:  SUBWF  28,W
06F8:  BTFSC  03.0
06F9:  GOTO   711
....................             /*BufferRegister[i+15] = modbus_rx.data[i]; //! Start Address 16*/ 
....................             printf("%X ", modbus_rx.data[i]); 
06FA:  MOVLW  0F
06FB:  ADDWF  28,W
06FC:  MOVWF  04
06FD:  MOVLW  20
06FE:  MOVWF  05
06FF:  BTFSC  03.0
0700:  INCF   05,F
0701:  MOVF   00,W
0702:  MOVWF  29
0703:  MOVWF  2A
0704:  MOVLW  37
0705:  MOVWF  2B
0706:  MOVLB  00
0707:  CALL   525
0708:  MOVLW  20
0709:  MOVLB  0E
070A:  BTFSS  0F.4
070B:  GOTO   70A
070C:  MOVLB  02
070D:  MOVWF  1A
070E:  MOVLB  01
070F:  INCF   28,F
0710:  GOTO   6F4
....................          } 
....................          printf("\r\n\r\n"); 
0711:  MOVLW  34
0712:  MOVLB  10
0713:  MOVWF  1A
0714:  MOVLW  03
0715:  MOVWF  1B
0716:  MOVLB  00
0717:  CALL   36C
....................       } 
0718:  GOTO   736
....................       else 
....................       { 
....................          printf("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0719:  MOVLW  37
071A:  MOVLB  10
071B:  MOVWF  1A
071C:  MOVLW  03
071D:  MOVWF  1B
071E:  BCF    03.0
071F:  MOVLW  0E
0720:  MOVLB  01
0721:  MOVWF  29
0722:  MOVLB  00
0723:  CALL   54F
0724:  MOVF   2E,W
0725:  MOVLB  01
0726:  MOVWF  2A
0727:  MOVLW  37
0728:  MOVWF  2B
0729:  MOVLB  00
072A:  CALL   525
072B:  MOVLW  3F
072C:  MOVLB  10
072D:  MOVWF  1A
072E:  MOVLW  03
072F:  MOVWF  1B
0730:  BCF    03.0
0731:  MOVLW  08
0732:  MOVLB  01
0733:  MOVWF  29
0734:  MOVLB  00
0735:  CALL   54F
....................       } 
....................        
....................       delay_ms(200); 
0736:  MOVLW  C8
0737:  MOVLB  01
0738:  MOVWF  30
0739:  MOVLB  00
073A:  CALL   3BE
....................        
....................       if(!(modbus_read_input_registers(MODBUS_SLAVE_ADDRESS,Voltage_Address,2))) 
073B:  MOVLW  01
073C:  MOVLB  01
073D:  MOVWF  29
073E:  CLRF   2B
073F:  CLRF   2A
0740:  CLRF   2D
0741:  MOVLW  02
0742:  MOVWF  2C
0743:  MOVLB  00
0744:  CALL   406
0745:  MOVF   78,F
0746:  BTFSS  03.2
0747:  GOTO   777
....................       { 
....................          printf("Voltage: "); 
0748:  MOVLW  44
0749:  MOVLB  10
074A:  MOVWF  1A
074B:  MOVLW  03
074C:  MOVWF  1B
074D:  MOVLB  00
074E:  CALL   36C
....................          /*Started at 1 since 0 is quantity of coils*/ 
....................          for(i=1; i < (modbus_rx.len); ++i){ 
074F:  MOVLW  01
0750:  MOVLB  01
0751:  MOVWF  28
0752:  MOVLB  00
0753:  MOVF   2C,W
0754:  MOVLB  01
0755:  SUBWF  28,W
0756:  BTFSC  03.0
0757:  GOTO   76F
.................... //!            BufferRegister[i+7] = modbus_rx.data[i]; //! Start Address 8 
....................             printf("%X ", modbus_rx.data[i]); 
0758:  MOVLW  0F
0759:  ADDWF  28,W
075A:  MOVWF  04
075B:  MOVLW  20
075C:  MOVWF  05
075D:  BTFSC  03.0
075E:  INCF   05,F
075F:  MOVF   00,W
0760:  MOVWF  29
0761:  MOVWF  2A
0762:  MOVLW  37
0763:  MOVWF  2B
0764:  MOVLB  00
0765:  CALL   525
0766:  MOVLW  20
0767:  MOVLB  0E
0768:  BTFSS  0F.4
0769:  GOTO   768
076A:  MOVLB  02
076B:  MOVWF  1A
076C:  MOVLB  01
076D:  INCF   28,F
076E:  GOTO   752
....................          } 
....................          printf("\r\n\r\n"); 
076F:  MOVLW  49
0770:  MOVLB  10
0771:  MOVWF  1A
0772:  MOVLW  03
0773:  MOVWF  1B
0774:  MOVLB  00
0775:  CALL   36C
....................       } 
0776:  GOTO   794
....................       else 
....................       { 
....................          printf("<-**Exception %X**->\r\n\r\n", modbus_rx.error); 
0777:  MOVLW  4C
0778:  MOVLB  10
0779:  MOVWF  1A
077A:  MOVLW  03
077B:  MOVWF  1B
077C:  BCF    03.0
077D:  MOVLW  0E
077E:  MOVLB  01
077F:  MOVWF  29
0780:  MOVLB  00
0781:  CALL   54F
0782:  MOVF   2E,W
0783:  MOVLB  01
0784:  MOVWF  2A
0785:  MOVLW  37
0786:  MOVWF  2B
0787:  MOVLB  00
0788:  CALL   525
0789:  MOVLW  54
078A:  MOVLB  10
078B:  MOVWF  1A
078C:  MOVLW  03
078D:  MOVWF  1B
078E:  BCF    03.0
078F:  MOVLW  08
0790:  MOVLB  01
0791:  MOVWF  29
0792:  MOVLB  00
0793:  CALL   54F
....................       } 
0794:  MOVLB  01
0795:  GOTO   61A
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
0796:  SLEEP

Configuration Fuses:
   Word  1: 3F8C   NOEXTOSC RSTOSC_HFINTRC NOCLKOUT CKS FCMEN
   Word  2: 3FFD   MCLR PUT NOLPBOR BROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG
   Word  3: 3F9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: 3FFF   BBSIZ512 NOBOOTBLOCK NOSAF NOWRT NOWRTB NOWRTC NOWRTSAF LVP
   Word  5: 3FFF   NOPROTECT
